# 1.7 다 쓴 객체 참조를 해제하라

> C 나 C++처럼 메모리를 직접 관리해야하는 언어를 사용하다, Java를 사용하는 순간,
>
> **가비지컬렉터** 를 만나는 순간, 삶이 평안해지는 것을 경험했을 것이다.(물론 나는 C, C++ 다 안써봤다 ㅎ)
>
> 그러나, 전혀 그렇지 않다는 것을 이번 장에서 알게 될 것이고, 알아야 할 것이다.



### 아래 코드는 Stack의 동작들을 구현한 코드이다. 하지만 이 코드에서 메모리 누수가 발생한다. 과연 어디일까 ?

<img src="/Users/hansangjin/Library/Application Support/typora-user-images/image-20220722005122453.png" alt="image-20220722005122453" style="zoom:50%;" />



#### 그것은 바로, `pop()` 메소드를 실행할 때 발생한다.

기본적으로, 메모리의 누수가 발생한다는 것은, 다 쓴 객체의 참조값이 그대로 유지되고 있을때를 의미한다. 

`pop()` 메소드를 실행하게되면 가장 마지막에 있는 객체는 stack에서 빠져나가게된다. 그렇지만 해당 메모리에 참조값은 남아있는 상태이다. 따라서 GC가 해당 객체가 사용되고 남은 객체라는 것을 정확히 인지하지 못해, 메모리 누수가 발생하게 된다.

다음은 `pop()` 메소드를 수정해본 부분이다.

​	<img src="/Users/hansangjin/Library/Application Support/typora-user-images/image-20220722012127020.png" alt="image-20220722012127020" style="zoom: 67%;" />

사용하지 않는 객체는 참조값을 `null` 처리하므로, 메모리관리도 용이하고 나중에 해당 객체를 사용하려할 때 `NullPointException` 을 발생시킨다. 



#### 그렇다면 항상 이렇게 모든 사용하지 않는 원소들을 Null처리 해야할까 ?

- 정답은 항상은 아니다. 하지만 특별하게, **메모리를 직접관리하는 class**들은 참조를 해제해주는 작업을 진행해야한다.
# Sort에 관해 궁금즘 해결

## 1. 내부 정렬과 외부 정렬

- 내부정렬
  - 메모리에 모든 값을 담아서 정렬하는 알고리즘
- 외부정렬
  - 외부 저장 장치에서 일부 데이터를 읽어오고 정렬하고 다시 외부장치에 작성하고 다시 읽어와서 정렬하는 알고리즘



## 2. 안정적인 정렬

- 반복되는 요소를 입력 때와 동일한 순서로 정렬시킨다.

- 특정한 유형의 데이터를 정렬할 때, 정렬 순서 결정 시 데이터의 일부만 검사한다.

  > 예시 )
  >
  > ​	데이터가 **학생 이름으로 우선 정렬**되면 
  >
  > ​	( 일부의 경우 웹 페이지에 동적으로 )
  >
  > ​	데이터는 이제 어느 학급에 위치하는지에 따라 다시 정렬된다. 
  >
  > ​	학생들이 같은 학급에 있다고 가정한다면 이들의 이름 순서는 
  >
  > ​	특정한 순서가 아니게 뒤섞이며, 이는 성가신 문제일 수 있다. 
  >
  > ​	정렬 알고리즘이 안정적이면 학생 이름은 정상적인 순서에 
  >
  > ​	위치할 수 있다.
  >
  > 참고 : https://godgod732.tistory.com/10

> MergeSort(합병정렬) 과 QuickSort(퀵소트) 의 차이점
>
> 합병정렬은 안정적인 정렬
>
> 퀵정렬은 불안정적 정렬
>
> - Merge Sort는 특정 값을 기준으로 비교하는 것이 아닌 전체 배열을 반으로 나눠 서로를 비교하면서 자리를 바꾸므로 항상 같은 값에 대해 일정 순서를 유지하고 있다. 
>
> - 반면에, 퀵소트는 값 중에 특정 하나를 기준으로 양쪽을 비교하며 바꾸기 때문에 같은 값에 대한 순서가 바뀔 수 있다.  



### 시간복잡도가 `O(n logn)` 이라는 말은 실제론 `C * n logn + a` 라는 의미

- 실제 n logn 앞에 `C` 가 실제 동작에 큰 영향을 미칠 수 있다. 

  이 `C` 에 영향을 끼치는 요소로 알고리즘이

  ' `참조 지역성` 원리를 얼마나 잘 만족하는가 ' 가 있다.  

> **참조지역성** 이란
>
> - CPU가 미래에 원하는 데이터를 예측하여 속도가 빠른 장치인  캐시메모리에 담아 놓는데, 이 때에 예측률을 높이기 위하여 사용하는 원리이다. 
>
>   쉽게 말하면, 최근에 참조한 메모리나 그 메모리와 인접한 메모리를 다시 참조할 확률이 높다는 이론을 기반으로 캐시 메모리에 담아 놓는 것이다. 
>
>   메모리를 연속으로 읽는 작업은 캐시 메모리에서 읽어오기에 빠른 반면, 무작위로 읽는 작업은 메인 메모리에서 읽어오기에 속도의 차이가 있다. 



## 참조 지역성 측면에서 바라본 알고리즘

### 1.  Heap Sort

- 힙소트의 경우 Tree를 구성하는 과정에서 인덱스로 접근할 때, 두 배 또는 절반의 인덱스를 참조해야하기 때문에, 참조 지역성 측면에서 가장 안좋은 성능을 나타낸다. 

  따라서 `nlogn 시간복잡도를 갖는 알고리즘 중 C 가 가장 크다.`



### 2. Merge Sort 

- 합병정렬은 데이터를 절반으로 나눠 정렬하고 합치는 과정에서 값의 분포도가 일정하게 나눠져 `참조지역성을 만족시키기에 충분하다` 

  하지만, 합병정렬은 기존 메모리와 더불어 정렬한 배열을 저장하기 위한 추가 메모리가 필요하다는 점에서 단점을 가지고 있다. 



### 3. Quick Sort 

- 퀵소트 또한 Pivot 값을 기준으로 작은 값, 큰 값을 나누는 과정에서 참조 지역성을 만족시키게끔 동작한다. 심지어 메모리도 추가로 사용하지 않는다는 점에서 굉장히 큰 장점을 가지고 있다. 

  하지만, 최악의 경우 ( 배열이 정렬이 어느정도 되어 있는 경우 ) `O(N^2)` 의 성능을 낼 수 있다.

---

## Tim Sort

- 실생활의 데이터의 특성을 고려하여 더욱 빠르게 고안된 이 알고리즘은 `최선의 시간 복잡도는 O(n)` 

  `평균은 O(n logn)`

  `최악의 경우 O(n logn)` 이다.

- `Insertion sort` 와 `Merge sort` 를 합친 정렬 

  - 안정적 + 안정적 정렬이기에 안정적이고

- 추가 메모리를 사용하긴 하지만 `Merge Sort` 에 비해 적은 추가 메모리를 사용
